const fs = require("fs");
const path = require("path");
function solveTurnstileMin({ url, proxy, siteKey }) {
  return new Promise(async (resolve, reject) => {
    if (!url) return reject("Missing url parameter");
    if (!siteKey) return reject("Missing siteKey parameter");

    const context = await global.browser
      .createBrowserContext({
        // Proxy intentionally removed
      })
      .catch(() => null);
    if (!context) return reject("Failed to create browser context");

    let isResolved = false;

    var cl = setTimeout(async () => {
      if (!isResolved) {
        try { await context.close(); } catch (e) { }
        reject("Timeout Error");
      }
    }, global.timeOut || 60000);

    try {
      const page = await context.newPage();
      page.on('console', msg => console.log(`[MIN-PAGE-LOG] ${msg.text()}`));

      try {
        const session = await page.target().createCDPSession();
        const { windowId } = await session.send('Browser.getWindowForTarget');
        await session.send('Browser.setWindowBounds', {
          windowId,
          bounds: { windowState: 'normal' }
        });
        // Also bring to front
        await page.bringToFront();
      } catch (e) {
        console.log("Failed to restore window:", e.message);
      }

      // Proxy authentication intentionally removed
      console.log(`[SOLVER] Sitekey Mode: DOM Replacement for ${url}`);

      // FIRST: Navigate to the target origin to establish context
      // We use a sub-path to avoid any original page scripts interfering
      try {
        const origin = new URL(url).origin;
        await page.goto(`${origin}/robots.txt`, { waitUntil: 'domcontentloaded', timeout: 30000 }).catch(() => { });
      } catch (e) {
        console.log(`[SOLVER] Context navigation failed: ${e.message}`);
      }

      // Inject the fakePage HTML via DOM replacement
      const fakePagePath = path.join(__dirname, "..", "data", "fakePage.html");
      let body = fs.readFileSync(fakePagePath, "utf8");
      body = body.replace(/<site-key>/g, siteKey);

      await page.evaluate((html) => {
        window.stop();
        document.open();
        document.write(html);
        document.close();
      }, body);

      // Simulate some mouse movement to help Turnstile
      const mouseLoop = setInterval(async () => {
        if (isResolved) return clearInterval(mouseLoop);
        try {
          await page.mouse.move(Math.random() * 500, Math.random() * 500);
        } catch (e) { }
      }, 2000);

      await page.waitForSelector('[name="cf-response"]', {
        timeout: 60000,
      });

      // DEBUG: Take a screenshot
      const screenshotPath = path.join(process.cwd(), 'solver_debug.png');
      try { await page.screenshot({ path: screenshotPath }); } catch (e) { }
      console.log(`[SOLVER] Screenshot saved to: ${screenshotPath}`);

      const token = await page.evaluate(() => {
        try {
          return document.querySelector('[name="cf-response"]').value;
        } catch (e) {
          return null;
        }
      });

      isResolved = true;
      clearInterval(mouseLoop);
      clearInterval(cl);
      try { await context.close(); } catch (e) { }
      if (!token || token.length < 10) return reject("Failed to get token");
      return resolve(token);
    } catch (e) {
      if (!isResolved) {
        try { await context.close(); } catch (e) { }
        clearInterval(cl);
        reject(e.message);
      }
    }
  });
}
module.exports = solveTurnstileMin;
